; OM File Header - Saved 2009/10/26 10:58:39
; (6.0011 :patc (om-make-point 49 304) (om-make-point 50 50) (om-make-point 500 400) "" 183 0 nil "2009/10/26 10:58:33")
; End File Header
(in-package :om)(load-lib-for (quote ("OMRC" "OMCS")))(setf *om-current-persistent* (om-load-patch1 "rc tutorial-06" (quote ((om-load-boxcall (quote genfun) "PMC-ENGINE" (quote omcs::pmc-engine) (quote ((om-load-inputfun (quote input-funbox) "s-space" "S-SPACE" nil) (om-load-inputfun (quote input-funbox) "rules" "RULES" nil) (om-load-inputfun (quote input-funbox) "heuristic-rules" "HEURISTIC-RULES" nil) (om-load-inputfun (quote input-funbox) "fwc-rules" "FWC-RULES" nil) (om-load-inputfun (quote input-funbox) "sols-mode" "SOLS-MODE" (quote :once)) (om-load-inputfun (quote input-funbox) "random?" "RND?" (quote t)) (om-load-inputfun (quote input-funbox) "print-indexnr?" "PRINT-FL" nil))) (om-make-point 187 397) nil nil nil nil 1) (om-load-boxcall (quote genfun) "TREE->SIMPLEFORMAT" (quote rc::tree->simpleformat) (quote ((om-load-inputfun (quote input-funbox) "tree" "TREE" (list 2 (list (list (list 4 4) (list 1 (list 1 (list 1 -2 1 1)) 1 1)) (list (list 4 4) (list 1 (list 1 (list 1 2 1 1)) -1 1))))))) (om-make-point 104 101) nil nil nil nil 1) (om-load-editor-box1 "POLY" (quote poly) (quote ((om-load-inputfun (quote input-funbox) "objs" "SELF" nil) (om-load-inputfun (quote input-funbox) "VOICES" "VOICES" (list (let ((newobj (when (find-class (quote voice) nil) (make-instance (quote voice) :tree (quote (2 (((4 4) (1 (1 (1 -2 1 1)) 1 1)) ((4 4) (1 (1 (1 2 1 1)) -1 1))))) :chords (load-obj-list-from-save (quote ((let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (400)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord)))) :tempo (quote ((1/4 60) nil)) :legato 100 :ties (quote (nil nil nil nil nil nil nil nil nil nil nil nil)))))) (load-port-info newobj (quote (((0) ((0) nil (0) (0)) (0) (0)) ((0) ((0) (0) (0) (0)) nil (0))))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-tonalite newobj nil) newobj))))) (om-make-point 81 478) (om-make-point 544 105) (if (find-class (quote poly) nil) (let ((newobj (make-instance (quote poly) :voices (list (let ((newobj (when (find-class (quote voice) nil) (make-instance (quote voice) :tree (quote (75/16 (((4 4) ((1 (1 1 1 1 1)) (1 (1 1 1 1)) 2.0)) ((1 16) (1)) ((1 4) ((1 (1 1 1 1 1)))) ((1 16) (1)) ((1 4) ((1 (1 1 1 1 1)))) ((1 16) (1)) ((4 4) ((1 (1 1 1 1 1)) (1 (1 3)) (1 (2.0 1 1)) 1)) ((4 4) (1.0 (1 (1.0 1)) 2.0)) ((4 4) (1.0 (1 (1.0 3)) 2.0))))) :chords (load-obj-list-from-save (quote ((let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (116)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (116)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (116)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (116)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (116)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (146)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (146)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (146)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (146)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (146)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (116)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (116)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (116)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (116)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (116)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (146)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (116)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (116)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (116)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (116)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (116)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (146)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (116)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (116)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (116)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (116)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (116)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (146)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (436)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (146)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (146)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (582)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (291)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (436)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord)))) :tempo (quote ((1/4 102) nil)) :legato 99 :ties (quote (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)))))) (load-port-info newobj (quote ((((0) (0) (0) (0) (0)) ((0) (0) (0) (0)) (0)) ((0)) (((0) (0) (0) (0) (0))) ((0)) (((0) (0) (0) (0) (0))) ((0)) (((0) (0) (0) (0) (0)) ((0) (0)) ((0) (0) (0)) (0)) ((0) ((0) (0)) (0)) ((0) ((0) (0)) (0))))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-tonalite newobj nil) newobj)) :from-file t))) (load-port-info newobj (quote (((((0) (0) (0) (0) (0)) ((0) (0) (0) (0)) (0)) ((0)) (((0) (0) (0) (0) (0))) ((0)) (((0) (0) (0) (0) (0))) ((0)) (((0) (0) (0) (0) (0)) ((0) (0)) ((0) (0) (0)) (0)) ((0) ((0) (0)) (0)) ((0) ((0) (0)) (0)))))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-tonalite newobj nil) newobj)) nil nil (pairlis (quote (scale microplay obj-mode palette-mode approx fontsize staff cmnpref deltapict outport inport zoom notechancolor? grillestep mode winsize winpos show-stems)) (list nil nil 0 0 2 28 (list (quote g)) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) 0 0 1 nil 1000 0 18350450 2621450 (quote t))) t nil nil nil) (om-load-editor-box1 "VOICE1" (quote voice) (quote ((om-load-inputfun (quote input-funbox) "objs" "SELF" nil) (om-load-inputfun (quote input-funbox) "TREE" "TREE" (list (quote ?) (list (list (quote |4//4|) (list 1 (list 1 (list 1 -2 1 1)) 1 1)) (list (quote |4//4|) (list 1 (list 1 (list 1 2 1 1)) -1 1))))) (om-load-inputfun (quote input-funbox) "CHORDS" "CHORDS" (list (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord))) (om-load-inputfun (quote input-funbox) "TEMPO" "TEMPO" 60) (om-load-inputfun (quote input-funbox) "LEGATO" "LEGATO" 100) (om-load-inputfun (quote input-funbox) "TIES" "TIES" nil))) (om-make-point 95 10) (om-make-point 609 89) (let ((newobj (when (find-class (quote voice) nil) (make-instance (quote voice) :tree (quote (7 (((4 4) ((1 (1 1 1 1 1)) (1 (1 1 1 1)) 2.0)) ((4 4) ((1 (4.0 1.0 4 4 4 3)) (1 (1.0 4 4 1.0 4 4 2)) (1 (2.0 4 4 4 1.0 4 1)) (1 (3.0 4 4 4 4 1.0)))) ((4 4) (1 (1 (1.0 1 1 1)) 2.0)) ((4 4) ((1 (1.0 3)) 3.0)) ((4 4) (4)) ((4 4) (4)) ((4 4) ((1 (1.0 -3)) -3))))) :chords (load-obj-list-from-save (quote ((let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (250)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (250)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (250)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (250)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (150)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (50)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (250)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (250)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (250)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (750)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (4000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (4000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord)))) :tempo (quote ((1/4 60) nil)) :legato 100 :ties (quote (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)))))) (load-port-info newobj (quote ((((0) (0) (0) (0) (0)) ((0) (0) (0) (0)) (0)) (((0) (0) (0) (0) (0) (0)) ((0) (0) (0) (0) (0) (0) (0)) ((0) (0) (0) (0) (0) (0) (0)) ((0) (0) (0) (0) (0) (0))) ((0) ((0) (0) (0) (0)) (0)) (((0) (0)) (0)) ((0)) ((0)) (((0) nil) nil)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-tonalite newobj nil) newobj) "x" nil (pairlis (quote (scale microplay obj-mode palette-mode approx fontsize staff cmnpref deltapict outport inport zoom notechancolor? grillestep mode winsize winpos show-stems)) (list nil nil 0 0 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) 0 0 1 nil 1000 0 18350450 2621450 (quote t))) t nil nil nil) (om-load-boxcall (quote bastype) "aux8" (quote t) (quote nil) (om-make-point 332 172) (om-make-point 30 28) (list 1) "(1)" nil) (om-load-boxcall (quote bastype) "aux7" (quote t) (quote nil) (om-make-point 299 172) (om-make-point 26 28) 16 "16" nil) (om-load-boxcall (quote bastype) "aux6" (quote t) (quote nil) (om-make-point 279 147) (om-make-point 50 28) (list 1 2 3) "(1 2 3)" nil) (om-load-boxcall (quote bastype) "aux5" (quote t) (quote nil) (om-make-point 252 155) (om-make-point 20 28) 8 "8" nil) (om-load-boxcall (quote bastype) "aux4" (quote t) (quote nil) (om-make-point 248 117) (om-make-point 80 28) (list 1 2 3 4 5 6) "(1 2 3 4 5 6)" nil) (om-load-boxcall (quote bastype) "aux3" (quote t) (quote nil) (om-make-point 218 128) (om-make-point 20 28) 4 "4" nil) (om-load-boxcall (quote bastype) "aux2" (quote t) (quote nil) (om-make-point 203 173) (om-make-point 20 28) 1 "1" nil) (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 307 266) (om-make-point 183 37) nil nil nil 1) (om-load-boxcall (quote abstraction) "mypatch13" (om-load-patch-abs1 "timesign2" (quote ((om-load-boxcall (quote bastype) "aux1" (quote t) (quote nil) (om-make-point 140 212) (om-make-point 11 20) 0 "0" nil) (om-load-boxcomment "comment11" (om-make-point 263 88) (quote "The rule checks if the variable is a time signature. If no, it outputs 0 (no weight), if yes it outputs 80 divided by the second number in the time signature, i.e. the higher beat value, the lower weight. ") "" (om-make-point 159 254) nil (om-make-color 0 0 0) (om-make-font "Geneva" 10 :family "Geneva" :style (quote (:plain)) :mode (quote nil))) (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 152 169) (om-make-point 17 20) 80 "80" nil) (om-load-boxcomment "comment2" (om-make-point 237 40) (quote "<-- The 2 inputs are identical to the inputs in user defined rules (see tutorial-05a).") "" (om-make-point 231 59) nil (om-make-color 0 0 0) (om-make-font "Geneva" 10 :family "Geneva" :style (quote (:plain)) :mode (quote nil))) (om-load-boxcall (quote genfun) "OM/" (quote om/) (quote ((om-load-inputfun (quote input-funbox) "number or tree" "SELF" 80) (om-load-inputfun (quote input-funbox) "number or tree" "NUM" 1))) (om-make-point 177 201) (om-make-point 38 35) nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 185 161) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "if" "TEST" nil) (om-load-inputfun (quote input-funbox) "then" "ACTION" nil) (om-load-inputfun (quote input-funbox) "else" "ELSE" 0))) (om-make-point 108 242) (om-make-point 46 53) nil nil nil 1) (om-load-boxcall (quote genfun) "TIMESIGN?" (quote rc::timesign?) (quote ((om-load-inputfun (quote input-funbox) "search-var" "X" nil))) (om-make-point 92 105) nil nil nil nil 1) (om-load-boxcall (quote genfun) "GET-THIS-CELL" (quote rc::get-this-cell) (quote ((om-load-inputfun (quote input-funbox) "search-var" "X" nil))) (om-make-point 165 105) nil nil nil nil 1) (om-load-boxin "input1" 1 (om-make-point 147 39) "no documentation" nil nil nil) (om-load-boxin "input" 0 (om-make-point 5 45) "no documentation" nil nil nil) (om-load-boxout "output" 0 (om-make-point 109 313) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (quote ((2 0 4 0 nil 0) (5 0 4 1 nil 0) (8 0 5 0 nil 0) (7 0 6 0 nil 0) (4 0 6 1 nil 0) (0 0 6 2 nil 0) (9 0 7 0 nil 0) (9 0 8 0 nil 0) (6 0 11 0 nil 0))) 6.04 nil) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil))) (om-make-point 405 198) nil nil "l" "timesign2") (om-load-boxcall (quote abstraction) "mypatch2" (om-load-patch-abs1 "timesign1" (quote ((om-load-boxcomment "comment1" (om-make-point 263 88) (quote "The rule checks if the variable is a time signature. If no, it outputs 0 (no weight), if yes it outputs the first number in the time signature, i.e. the number of beats. The rule will thus prefere timesignatures with many beats (since they will give high weights).") "" (om-make-point 94 255) nil (om-make-color 0 0 0) (om-make-font "Geneva" 10 :family "Geneva" :style (quote (:plain)) :mode (quote nil))) (om-load-boxcomment "comment" (om-make-point 237 40) (quote "<-- The 2 inputs are identical to the inputs in user defined rules (see tutorial-05a).") "" (om-make-point 119 61) nil (om-make-color 0 0 0) (om-make-font "Geneva" 10 :family "Geneva" :style (quote (:plain)) :mode (quote nil))) (om-load-boxcall (quote bastype) "number" (quote number) (quote nil) (om-make-point 70 195) (om-make-point 14 20) 0 "0" nil) (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "if" "TEST" nil) (om-load-inputfun (quote input-funbox) "then" "ACTION" nil) (om-load-inputfun (quote input-funbox) "else" "ELSE" 0))) (om-make-point 39 227) (om-make-point 46 53) nil nil nil 1) (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 118 179) nil nil nil "first" 1) (om-load-boxcall (quote genfun) "TIMESIGN?" (quote rc::timesign?) (quote ((om-load-inputfun (quote input-funbox) "search-var" "X" nil))) (om-make-point 23 123) nil nil nil nil 1) (om-load-boxcall (quote genfun) "GET-THIS-CELL" (quote rc::get-this-cell) (quote ((om-load-inputfun (quote input-funbox) "search-var" "X" nil))) (om-make-point 96 123) nil nil nil nil 1) (om-load-boxin "input1" 1 (om-make-point 78 46) "no documentation" nil nil nil) (om-load-boxin "input" 0 (om-make-point 9 46) "no documentation" nil nil nil) (om-load-boxout "output" 0 (om-make-point 40 286) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (quote ((5 0 3 0 nil 0) (4 0 3 1 nil 0) (2 0 3 2 nil 0) (6 0 4 0 nil 0) (7 0 5 0 nil 0) (7 0 6 0 nil 0) (3 0 9 0 nil 0))) 6.04 nil) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil))) (om-make-point 341 201) (om-make-point 58 61) nil "l" "timesign1") (om-load-boxcall (quote genfun) "HEURISTICRULES->PMC" (quote rc::heuristicrules->pmc) (quote ((om-load-inputfun (quote input-funbox) "heur.rules" "VOICE0" nil))) (om-make-point 337 307) nil nil nil nil 1) (om-load-boxcall (quote genfun) "DECODE-ENGINE1" (quote rc::decode-engine) (quote ((om-load-inputfun (quote input-funbox) "from engine" "SOL" nil) (om-load-inputfun (quote input-funbox) "bpm" "TEMPO" 102) (om-load-inputfunmenu1 (quote input-funmenu) "format" "OUTPUT" (quote rc::voice) (list (list "poly-list" (quote (quote rc::poly))) (list "voice-list" (quote (quote rc::voice))) (list "simple" (quote (quote rc::simple))))))) (om-make-point 327 406) nil nil nil nil 1) (om-load-boxcall (quote genfun) "R-BEAT-SUBDIV" (quote rc::r-beat-subdiv) (quote ((om-load-inputfun (quote input-funbox) "rhythmlayer" "RHYTHM-LAYER-NR" 1) (om-load-inputfun (quote input-funbox) "beatvalue" "BEATVALUE1" 4) (om-load-inputfun (quote input-funbox) "subdiv-list" "SUBDIV1" (list 1 2 3 4 5 6)) (om-load-inputfun (quote input-funbox) "beatvalue" "BEATVALUE2" 8) (om-load-inputfun (quote input-funbox) "subdiv-list" "SUBDIV2" (list 1 2 3)) (om-load-inputfun (quote input-funbox) "beatvalue" "BEATVALUE3" 16) (om-load-inputfun (quote input-funbox) "subdiv-list" "SUBDIV3" (list 1)))) (om-make-point 196 204) (om-make-point 120 53) nil nil nil 1) (om-load-boxcall (quote genfun) "PRESET-LAYER" (quote rc::preset-layer) (quote ((om-load-inputfun (quote input-funbox) "measurelayer" "RHYTHMSEQ" (list 1/4 1/4 1/4 1/4 1/4 1/4 1/4 1/4)))) (om-make-point 121 163) nil nil nil nil 1) (om-load-boxcall (quote bastype) "aux1" (quote t) (quote nil) (om-make-point 8 161) (om-make-point 106 64) (list (list 1 4) (list 4 4) (list 3 4) (list 2 4) (list 6 8) (list 5 8) (list 3 8) (list 2 8) (list 5 16) (list 3 16) (list 1 16)) "((1 4)(4 4)(3 4)(2 4)(6 8)(5 8)(3 8)(2 8)(5 16)(3 16)(1 16))" nil) (om-load-boxcall (quote genfun) "RULES->PMC1" (quote rc::rules->pmc) (quote ((om-load-inputfun (quote input-funbox) "rules" "VOICE0" nil))) (om-make-point 222 265) nil nil nil nil 1) (om-load-boxcall (quote genfun) "VOICE-DOMAIN1" (quote rc::voice-domain) (quote ((om-load-inputfun (quote input-funbox) "timesigns" "TIMESIGN-LIST" nil) (om-load-inputfun (quote input-funbox) "layer1" "RHYTHMCELL-LIST1" nil))) (om-make-point 104 264) nil nil nil nil 1) (om-load-boxcall (quote genfun) "DOMAINS->PMC1" (quote rc::domains->pmc) (quote ((om-load-inputfun (quote input-funbox) "number of variables" "N-VAR" 9) (om-load-inputfun (quote input-funbox) "voice-domain" "VOICE0" nil))) (om-make-point 88 332) nil nil nil nil 1))) (quote ((21 0 0 0 nil 0) (19 0 0 1 nil 0) (14 0 0 2 nil 0) (3 1 1 0 nil 0) (15 0 2 1 nil 0) (13 0 11 0 nil 0) (12 0 11 1 nil 0) (11 0 14 0 nil 0) (0 0 15 0 nil 0) (10 0 16 0 nil 0) (9 0 16 1 nil 0) (8 0 16 2 ((om-make-point 286 143) (om-make-point 277 150) (om-make-point 241 150) (om-make-point 241 204)) 0) (7 0 16 3 nil 0) (6 0 16 4 ((om-make-point 302 173) (om-make-point 289 176) (om-make-point 271 176) (om-make-point 271 204)) 0) (5 0 16 5 nil 0) (4 0 16 6 nil 0) (1 0 17 0 nil 0) (16 0 19 0 nil 0) (18 0 20 0 nil 0) (17 0 20 1 nil 0) (20 0 21 1 nil 0))) nil 6.04))
