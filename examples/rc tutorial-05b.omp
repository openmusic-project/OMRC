; OM File Header - Saved 2009/10/26 10:58:39
; (6.0011 :patc (om-make-point 167 249) (om-make-point 50 50) (om-make-point 500 400) "" 183 0 nil "2009/10/26 10:58:33")
; End File Header
(in-package :om)(load-lib-for (quote ("OMCS" "OMRC")))(setf *om-current-persistent* (om-load-patch1 "rc tutorial-05b" (quote ((om-load-boxcall (quote bastype) "aux1" (quote t) (quote nil) (om-make-point 385 283) (om-make-point 11 20) (quote t) "t" nil) (om-load-boxcall (quote genfun) "R-LAYERORDER" (quote rc::r-layerorder) (quote ((om-load-inputfun (quote input-funbox) "layernr" "LAYER1" 0) (om-load-inputfun (quote input-funbox) "layernr" "LAYER2" 2) (om-load-inputfun (quote input-funbox) "duration" "ENDTIME" 5))) (om-make-point 784 93) nil nil nil nil 1) (om-load-boxcall (quote genfun) "R-EQLENGTH21" (quote rc::r-eqlength) (quote ((om-load-inputfun (quote input-funbox) "layernr" "LAYER1" 0) (om-load-inputfun (quote input-funbox) "layernr" "LAYER2" 2))) (om-make-point 709 95) nil nil nil nil 1) (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 12 54) (om-make-point 140 28) (list (list 4 4) (list 3 4) (list 3 8) (list 2 8)) "((4 4) (3 4) (3 8) (2 8))" nil) (om-load-editor-box1 "POLY" (quote poly) (quote ((om-load-inputfun (quote input-funbox) "objs" "SELF" nil) (om-load-inputfun (quote input-funbox) "VOICES" "VOICES" (list (let ((newobj (when (find-class (quote voice) nil) (make-instance (quote voice) :tree (quote (2 (((4 4) (1 (1 (1 -2 1 1)) 1 1)) ((4 4) (1 (1 (1 2 1 1)) -1 1))))) :chords (load-obj-list-from-save (quote ((let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (400)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord)))) :tempo (quote ((1/4 60) nil)) :legato 100 :ties (quote (nil nil nil nil nil nil nil nil nil nil nil nil)))))) (load-port-info newobj (quote (((0) ((0) nil (0) (0)) (0) (0)) ((0) ((0) (0) (0) (0)) nil (0))))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-tonalite newobj nil) newobj))))) (om-make-point 84 425) (om-make-point 638 183) (if (find-class (quote poly) nil) (let ((newobj (make-instance (quote poly) :voices (list (let ((newobj (when (find-class (quote voice) nil) (make-instance (quote voice) :tree (quote (11/2 (((2 8) (2)) ((3 8) (3)) ((3 4) (2.0 (1 (1.0 1)))) ((4 4) (4)) ((4 4) ((1 (1.0 1)) 3.0)) ((3 8) (3)) ((3 4) (3)) ((2 8) (2)) ((3 4) (1.0 2))))) :chords (load-obj-list-from-save (quote ((let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (990)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1485)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (3960)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1485)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (2970)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (990)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1980)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord)))) :tempo (quote ((1/4 60) nil)) :legato 99 :ties (quote (nil nil nil nil nil nil nil nil nil)))))) (load-port-info newobj (quote (((0)) ((0)) ((0) ((0) (0))) ((0)) (((0) (0)) (0)) ((0)) ((0)) ((0)) ((0) (0))))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote voice) nil) (make-instance (quote voice) :tree (quote (11/2 (((2 8) (1 (1 (1.0 1)))) ((3 8) (3)) ((3 4) (2.0 (1 (1.0 1)))) ((4 4) ((1 (1.0 1 2)) 1.0 (1 (3 1)) 1)) ((4 4) ((1 (2.0 1 1)) 1.0 (1 (1.0 3)) 1)) ((3 8) (1.0 1 (1 (1.0 1)))) ((3 4) (3)) ((2 8) (2)) ((3 4) ((1 (3 1)) (1 (3 1)) 1.0))))) :chords (load-obj-list-from-save (quote ((let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1485)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (742)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (990)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (742)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (990)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (2970)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (990)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (742)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (742)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord)))) :tempo (quote ((1/4 60) nil)) :legato 99 :ties (quote (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)))))) (load-port-info newobj (quote (((0) ((0) (0))) ((0)) ((0) ((0) (0))) (((0) (0) (0)) (0) ((0) (0)) (0)) (((0) (0) (0)) (0) ((0) (0)) (0)) ((0) (0) ((0) (0))) ((0)) ((0)) (((0) (0)) ((0) (0)) (0))))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote voice) nil) (make-instance (quote voice) :tree (quote (11/2 (((2 8) (1 (1 (1.0 1)))) ((3 8) (1 (1 (1.0 1)) 1.0)) ((3 4) ((1 (1 1 1 1 1)) (1 (1 1 1)) (1 (2 1 1)))) ((4 4) ((1 (1.0 1 2)) (1 (1.0 1 1)) (1 (3 1)) (1 (1 1)))) ((4 4) ((1 (2 1 1)) (1 (1.0 3)) (1 (1 3)) (1 (1 2)))) ((3 8) ((1 (1.0 2)) (1 (1 1)) (1 (1.0 1)))) ((3 4) ((1 (1 1 1)) (1 (1 1 1 1 1)) (1 (3 1)))) ((2 8) (1 (1 (1.0 1)))) ((3 4) ((1 (3 1)) (1 (2 1 -1)) -1))))) :chords (load-obj-list-from-save (quote ((let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (198)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (198)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (198)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (198)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (198)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (330)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (330)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (330)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (330)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (330)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (742)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (742)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (742)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (330)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (660)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (330)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (330)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (330)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (330)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (198)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (198)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (198)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (198)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (198)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (742)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (742)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord)))) :tempo (quote ((1/4 60) nil)) :legato 99 :ties (quote (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)))))) (load-port-info newobj (quote (((0) ((0) (0))) ((0) ((0) (0)) (0)) (((0) (0) (0) (0) (0)) ((0) (0) (0)) ((0) (0) (0))) (((0) (0) (0)) ((0) (0) (0)) ((0) (0)) ((0) (0))) (((0) (0) (0)) ((0) (0)) ((0) (0)) ((0) (0))) (((0) (0)) ((0) (0)) ((0) (0))) (((0) (0) (0)) ((0) (0) (0) (0) (0)) ((0) (0))) ((0) ((0) (0))) (((0) (0)) ((0) (0) nil) nil)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-tonalite newobj nil) newobj)) :from-file t))) (load-port-info newobj (quote ((((0)) ((0)) ((0) ((0) (0))) ((0)) (((0) (0)) (0)) ((0)) ((0)) ((0)) ((0) (0))) (((0) ((0) (0))) ((0)) ((0) ((0) (0))) (((0) (0) (0)) (0) ((0) (0)) (0)) (((0) (0) (0)) (0) ((0) (0)) (0)) ((0) (0) ((0) (0))) ((0)) ((0)) (((0) (0)) ((0) (0)) (0))) (((0) ((0) (0))) ((0) ((0) (0)) (0)) (((0) (0) (0) (0) (0)) ((0) (0) (0)) ((0) (0) (0))) (((0) (0) (0)) ((0) (0) (0)) ((0) (0)) ((0) (0))) (((0) (0) (0)) ((0) (0)) ((0) (0)) ((0) (0))) (((0) (0)) ((0) (0)) ((0) (0))) (((0) (0) (0)) ((0) (0) (0) (0) (0)) ((0) (0))) ((0) ((0) (0))) (((0) (0)) ((0) (0) nil) nil))))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-tonalite newobj nil) newobj)) nil nil (pairlis (quote (scale microplay obj-mode palette-mode inport outport deltapict cmnpref staff fontsize approx zoom notechancolor? grillestep mode winsize winpos show-stems)) (list nil nil 0 0 0 0 (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1 1 1))) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (list (quote g) (quote g) (quote g)) 24 2 1 nil 1000 0 18350450 2621450 (quote t))) t nil nil nil) (om-load-boxcall (quote genfun) "R-HIERARCHY11" (quote rc::r-hierarchy) (quote ((om-load-inputfun (quote input-funbox) "layernr" "LAYERHIGH" 1) (om-load-inputfun (quote input-funbox) "layernr" "LAYERLOW" 2))) (om-make-point 369 102) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list121" (quote list) (quote nil) (om-make-point 130 11) (om-make-point 99 40) (list 5/4 5/4 5/4 5/4 5/4 5/4 5/4) "(5/4 5/4 5/4 5/4$5/4 5/4 5/4)" nil) (om-load-boxcall (quote genfun) "PRESET-LAYER" (quote rc::preset-layer) (quote ((om-load-inputfun (quote input-funbox) "measurelayer" "RHYTHMSEQ" (list 1/4 1/4 1/4 1/4 1/4 1/4 1/4 1/4)))) (om-make-point 126 68) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list12" (quote list) (quote nil) (om-make-point 201 59) (om-make-point 85 40) (list (list 1) (list 3/8) (list 3/16) (list 1/16)) "((4/4)(3/8)$(3/16)(1/16))" nil) (om-load-boxcall (quote bastype) "list2" (quote list) (quote nil) (om-make-point 259 107) (om-make-point 80 51) (list (list 1/16) (list 1/8) (list 3/16) (list 1/20) (list 5/24) (list 1/12)) "((1/16)(1/8) (3/16)(1/20) (5/24)(1/12))" nil) (om-load-boxcall (quote genfun) "VOICE-DOMAIN1" (quote rc::voice-domain) (quote ((om-load-inputfun (quote input-funbox) "timesigns" "TIMESIGN-LIST" nil) (om-load-inputfun (quote input-funbox) "layer1" "RHYTHMCELL-LIST1" nil) (om-load-inputfun (quote input-funbox) "layer2" "RHYTHMCELL-LIST2" nil) (om-load-inputfun (quote input-funbox) "layer3" "RHYTHMCELL-LIST3" nil))) (om-make-point 127 172) nil nil nil nil 1) (om-load-boxcall (quote genfun) "DECODE-ENGINE1" (quote rc::decode-engine) (quote ((om-load-inputfun (quote input-funbox) "from engine" "SOL" nil) (om-load-inputfun (quote input-funbox) "bpm" "TEMPO" 60) (om-load-inputfunmenu1 (quote input-funmenu) "format" "OUTPUT" (quote rc::voice) (list (list "poly-list" (quote (quote rc::poly))) (list "voice-list" (quote (quote rc::voice))) (list "simple" (quote (quote rc::simple))))))) (om-make-point 344 368) nil nil nil nil 1) (om-load-boxcall (quote genfun) "R-BEAT-SUBDIV1" (quote rc::r-beat-subdiv) (quote ((om-load-inputfun (quote input-funbox) "rhythmlayer" "RHYTHM-LAYER-NR" 3) (om-load-inputfun (quote input-funbox) "beatvalue" "BEATVALUE1" 4) (om-load-inputfun (quote input-funbox) "subdiv-list" "SUBDIV1" (list 1 2 3 4 5)) (om-load-inputfun (quote input-funbox) "beatvalue" "BEATVALUE2" 8) (om-load-inputfun (quote input-funbox) "subdiv-list" "SUBDIV2" (list 1 2 3)))) (om-make-point 484 50) nil nil nil nil 1) (om-load-boxcall (quote genfun) "R-HIERARCHY1" (quote rc::r-hierarchy) (quote ((om-load-inputfun (quote input-funbox) "layernr" "LAYERHIGH" 2) (om-load-inputfun (quote input-funbox) "layernr" "LAYERLOW" 3))) (om-make-point 428 75) nil nil nil nil 1) (om-load-boxcall (quote genfun) "R-EQLENGTH2" (quote rc::r-eqlength) (quote ((om-load-inputfun (quote input-funbox) "layernr" "LAYER1" 2) (om-load-inputfun (quote input-funbox) "layernr" "LAYER2" 3))) (om-make-point 559 69) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "APPEND1" (quote append) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 449 180) (om-make-point 178 37) nil nil nil 1) (om-load-boxcall (quote genfun) "RULES->PMC1" (quote rc::rules->pmc) (quote ((om-load-inputfun (quote input-funbox) "rules" "VOICE0" nil))) (om-make-point 504 227) nil nil nil nil 1) (om-load-boxcall (quote genfun) "DOMAINS->PMC1" (quote rc::domains->pmc) (quote ((om-load-inputfun (quote input-funbox) "number of variables" "N-VAR" 80) (om-load-inputfun (quote input-funbox) "voice-domain" "VOICE0" nil))) (om-make-point 111 229) nil nil nil nil 1) (om-load-boxcall (quote genfun) "PMC-ENGINE1" (quote omcs::pmc-engine) (quote ((om-load-inputfun (quote input-funbox) "s-space" "S-SPACE" nil) (om-load-inputfun (quote input-funbox) "rules" "RULES" nil) (om-load-inputfun (quote input-funbox) "heuristic-rules" "HEURISTIC-RULES" nil) (om-load-inputfun (quote input-funbox) "fwc-rules" "FWC-RULES" nil) (om-load-inputfun (quote input-funbox) "sols-mode" "SOLS-MODE" (quote :once)) (om-load-inputfun (quote input-funbox) "random?" "RND?" (quote t)))) (om-make-point 335 313) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 642 104) nil nil nil nil 1) (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "2ndNotEq" (quote ((om-load-boxcomment "comment" (om-make-point 542 91) (quote "This rule check if the variable belongs to layer 2 or not. If not, it always gives true as an output (i.e. it will not affect other layers than number 2). If it does belong to layer 2, it checks if the element is identical to the one in layer 2 immediately before it. If it is identical, the output is false, otherwise true.$$The rule will not allow repetitions of the same element in layer 2.") "" (om-make-point 214 407) nil (om-make-color 0 0 0) (om-make-font "Geneva" 10 :family "Geneva" :style (quote (:plain)) :mode (quote nil))) (om-load-boxcomment "comment11" (om-make-point 207 314) (quote "A user defined rule always has 2 inputs. They are normally not accessed directly, but are used by the tools in the \"user rule tools\" menu to give the user access to different things. A basic example is the box \"get-this-cell\":$$Get-this-cell only has 1 input, and it should be connected to the second input to the patch. It outputs the variable (i.e. the element from the domain) that is beeing checked at the moment. $$Get-last-cell has 2 inputs. They should be connected to the 2 inputs to the patch. It outputs the variable in the same layer as the one beeing checked at the moment, immediately before the one beeing checked. The engine has thus already accepted this variable as true according to all rules (but might now reconsider that decision...).$$Get-layer-number outputs the layer number for the variable beeing checked.") "" (om-make-point 526 32) nil (om-make-color 0 0 0) (om-make-font "Helvetica" 10 :family "Helvetica" :style (quote (:plain)) :mode (quote nil))) (om-load-boxcomment "comment1" (om-make-point 191 43) (quote "<-- The second input gives the variable beeing checked for the moment (as an object).") "" (om-make-point 309 59) nil (om-make-color 0 0 0) (om-make-font "Helvetica" 10 :family "Helvetica" :style (quote (:plain)) :mode (quote nil))) (om-load-boxcomment "comment" (om-make-point 213 72) (quote "<-- The first input gives the index  number for the variable the search engine is checking for the moment. This is used internally to keep track on where the engine is in the search.") "" (om-make-point 44 60) nil (om-make-color 0 0 0) (om-make-font "Helvetica" 10 :family "Helvetica" :style (quote (:plain)) :mode (quote nil))) (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 169 383) (om-make-point 18 28) (quote t) "t" nil) (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "if" "TEST" nil) (om-load-inputfun (quote input-funbox) "then" "ACTION" nil) (om-load-inputfun (quote input-funbox) "else" "ELSE" nil))) (om-make-point 124 410) (om-make-point 67 53) nil nil nil 1) (om-load-boxcall (quote bastype) "number" (quote number) (quote nil) (om-make-point 456 238) (om-make-point 20 28) 2 "2" nil) (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "SELF" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM" 0))) (om-make-point 424 275) (om-make-point 35 35) nil nil nil 1) (om-load-boxcall (quote genfun) "TEST-NOT-EQUAL" (quote rc::test-not-equal) (quote ((om-load-inputfun (quote input-funbox) "event" "EV1" nil) (om-load-inputfun (quote input-funbox) "event" "EV2" nil))) (om-make-point 116 298) nil nil nil nil 1) (om-load-boxcall (quote genfun) "GET-LAYERNUMBER" (quote rc::get-layernumber) (quote ((om-load-inputfun (quote input-funbox) "search-var" "X" nil))) (om-make-point 389 183) nil nil nil nil 1) (om-load-boxcall (quote genfun) "GET-LAST-CELL" (quote rc::get-last-cell) (quote ((om-load-inputfun (quote input-funbox) "index" "INDEXX" nil) (om-load-inputfun (quote input-funbox) "search-var" "X" nil))) (om-make-point 24 183) nil nil nil nil 1) (om-load-boxcall (quote genfun) "GET-THIS-CELL" (quote rc::get-this-cell) (quote ((om-load-inputfun (quote input-funbox) "search-var" "X" nil))) (om-make-point 205 183) nil nil nil nil 1) (om-load-boxin "input1" 1 (om-make-point 267 42) "no documentation" nil nil nil) (om-load-boxin "input" 0 (om-make-point 5 45) "no documentation" nil nil nil) (om-load-boxout "output" 0 (om-make-point 136 486) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (quote ((7 0 5 0 nil 0) (8 0 5 1 nil 0) (4 0 5 2 nil 0) (9 0 7 0 nil 0) (6 0 7 1 nil 0) (10 0 8 0 nil 0) (11 0 8 1 nil 0) (12 0 9 0 nil 0) (13 0 10 0 nil 0) (12 0 10 1 nil 0) (12 0 11 0 nil 0) (5 0 14 0 nil 0))) 6.04 nil) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil))) (om-make-point 650 29) nil nil "l" "2ndNotEq"))) (quote ((11 0 4 1 nil 0) (6 0 7 0 nil 0) (3 0 10 0 nil 0) (7 0 10 1 nil 0) (8 0 10 2 nil 0) (9 0 10 3 nil 0) (18 0 11 0 nil 0) (5 0 15 0 nil 0) (13 0 15 1 nil 0) (12 0 15 2 nil 0) (14 0 15 3 nil 0) (19 0 15 4 nil 0) (2 0 15 5 nil 0) (15 0 16 0 nil 0) (10 0 17 1 nil 0) (17 0 18 0 nil 0) (16 0 18 1 nil 0) (0 0 18 5 nil 0) (20 0 19 0 nil 0))) nil 6.04))
