; OM File Header - Saved 2009/10/26 10:58:39
; (6.0011 :patc (om-make-point 168 302) (om-make-point 50 50) (om-make-point 500 400) "" 183 0 nil "2009/10/26 10:58:33")
; End File Header
(in-package :om)(load-lib-for (quote ("OMCS" "OMRC")))(setf *om-current-persistent* (om-load-patch1 "rc tutorial-07" (quote ((om-load-boxcall (quote genfun) "RULES->CSOLVER" (quote rc::rules->csolver) (quote ((om-load-inputfun (quote input-funbox) "rules" "VOICE0" nil))) (om-make-point 537 239) nil nil nil nil 1) (om-load-boxcall (quote bastype) "aux7" (quote t) (quote nil) (om-make-point 768 47) (om-make-point 20 28) 0 "0" nil) (om-load-boxinstance "STORED-SECTION1" (let ((copy (make-instance (quote ominstance) :name "stored-section" :icon (icon-from-lib 383 "OMRC")))) (setf (instance copy) (if (find-class (quote rc::stored-section) nil) (make-instance (quote rc::stored-section) :timesigns (list (list 3 4)) :layer1 (list 0) :layer2 (list 0 3/16 1/4 5/8 11/16) :layer3 (list 0 1/16 1/8 3/16 1/4 1/3 5/12 1/2 9/16 5/8 11/16) :layer4 nil :archiveinfo (list 0 3/4 0) :from-file t))) (setf (edition-params copy) (pairlis (quote (obj-mode palette-mode inport outport deltapict zoom cmnpref notechancolor? grillestep mode winsize winpos show-stems)) (list 0 0 0 0 (om-make-point 0 0) 1 (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) nil 1000 0 18350450 2621450 (quote t)))) (setf (create-info copy) (quote (nil "2008/11/06 18:27:57"))) (setf (doc copy) (str-with-nl "")) copy) (quote nil) (om-make-point 653 3) "stored-section" nil) (om-load-boxcall (quote bastype) "aux6" (quote t) (quote nil) (om-make-point 748 47) (om-make-point 20 28) 3 "3" nil) (om-load-boxcall (quote bastype) "aux5" (quote t) (quote nil) (om-make-point 728 47) (om-make-point 20 28) 2 "2" nil) (om-load-boxcall (quote bastype) "aux4" (quote t) (quote nil) (om-make-point 729 196) (om-make-point 35 20) (list 2 0) "(2 0)" nil) (om-load-boxcall (quote bastype) "aux3" (quote t) (quote nil) (om-make-point 708 177) (om-make-point 35 20) (list 1 0) "(1 0)" nil) (om-load-boxcall (quote bastype) "aux1" (quote t) (quote nil) (om-make-point 699 196) (om-make-point 11 20) 0 "0" nil) (om-load-boxcall (quote bastype) "aux2" (quote t) (quote nil) (om-make-point 413 310) (om-make-point 18 28) (quote t) "t" nil) (om-load-boxcall (quote genfun) "PMC-ENGINE" (quote omcs::pmc-engine) (quote ((om-load-inputfun (quote input-funbox) "s-space" "S-SPACE" nil) (om-load-inputfun (quote input-funbox) "rules" "RULES" nil) (om-load-inputfun (quote input-funbox) "heuristic-rules" "HEURISTIC-RULES" nil) (om-load-inputfun (quote input-funbox) "fwc-rules" "FWC-RULES" nil) (om-load-inputfun (quote input-funbox) "sols-mode" "SOLS-MODE" (quote :once)) (om-load-inputfun (quote input-funbox) "random?" "RND?" (quote t)) (om-load-inputfun (quote input-funbox) "print-indexnr?" "PRINT-FL" (quote t)))) (om-make-point 318 339) nil nil nil nil 1) (om-load-editor-box1 "POLY11" (quote poly) (quote ((om-load-inputfun (quote input-funbox) "objs" "SELF" nil) (om-load-inputfun (quote input-funbox) "VOICES" "VOICES" (list (let ((newobj (when (find-class (quote voice) nil) (make-instance (quote voice) :tree (quote (2 (((4 4) (1 (1 (1 -2 1 1)) 1 1)) ((4 4) (1 (1 (1 2 1 1)) -1 1))))) :chords (load-obj-list-from-save (quote ((let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (400)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord)))) :tempo (quote ((1/4 60) nil)) :legato 100 :ties (quote (nil nil nil nil nil nil nil nil nil nil nil nil)))))) (load-port-info newobj (quote (((0) ((0) nil (0) (0)) (0) (0)) ((0) ((0) (0) (0) (0)) nil (0))))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-tonalite newobj nil) newobj))))) (om-make-point 693 349) (om-make-point 80 50) (if (find-class (quote poly) nil) (let ((newobj (make-instance (quote poly) :voices (list (let ((newobj (when (find-class (quote voice) nil) (make-instance (quote voice) :tree (quote (1 (((1 1) (1))))) :chords (load-obj-list-from-save (quote ((let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (3960)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) thechord)))) :tempo (quote ((1/4 60) nil)) :legato 99 :ties (quote (nil)))))) (load-port-info newobj (quote (((nil))))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-tonalite newobj nil) newobj)) :from-file t))) (load-port-info newobj (quote ((((nil)))))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-tonalite newobj nil) newobj)) nil nil (pairlis (quote (scale microplay obj-mode palette-mode inport outport deltapict cmnpref staff fontsize approx zoom notechancolor? grillestep mode winsize winpos show-stems)) (list nil nil 0 0 0 0 (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (list (quote g) (quote g) (quote g)) 24 2 1 nil 1000 0 18350450 2621450 (quote t))) nil nil nil nil) (om-load-boxcall (quote genfun) "DECODE-STORED-SECTION1" (quote rc::decode-stored-section) (quote ((om-load-inputfun (quote input-funbox) "stored-section" "SECTION" nil))) (om-make-point 656 287) nil nil nil nil 1) (om-load-boxcall (quote genfun) "STORE-SECTION1" (quote rc::store-section) (quote ((om-load-inputfun (quote input-funbox) "voicenr" "VOICE" 0) (om-load-inputfun (quote input-funbox) "(measure offset)" "TIMEPOINT1" (list 2 0)) (om-load-inputfun (quote input-funbox) "(measure offset)" "TIMEPOINT2" (list 3 0)))) (om-make-point 682 226) nil nil nil nil 1) (om-load-boxcall (quote genfun) "R-LOCK-TO-STORED1" (quote rc::r-lock-to-stored) (quote ((om-load-inputfun (quote input-funbox) "from store-section" "SECTION" nil) (om-load-inputfun (quote input-funbox) "layernr" "LAYERNR0" 1) (om-load-inputfun (quote input-funbox) "layernr" "LAYERNR1" 2) (om-load-inputfun (quote input-funbox) "layernr" "LAYERNR2" 0))) (om-make-point 677 80) nil nil nil nil 1) (om-load-boxcall (quote genfun) "R-LAYERORDER" (quote rc::r-layerorder) (quote ((om-load-inputfun (quote input-funbox) "layernr" "LAYER1" 2) (om-load-inputfun (quote input-funbox) "layernr" "LAYER2" 3) (om-load-inputfun (quote input-funbox) "duration" "ENDTIME" 5))) (om-make-point 608 65) nil nil nil nil 1) (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 77 133) (om-make-point 81 45) (list (list 4 4) (list 3 4) (list 3 8) (list 2 8)) "((4 4) (3 4) (3 8) (2 8))" nil) (om-load-editor-box1 "POLY" (quote poly) (quote ((om-load-inputfun (quote input-funbox) "objs" "SELF" nil) (om-load-inputfun (quote input-funbox) "VOICES" "VOICES" (list (let ((newobj (when (find-class (quote voice) nil) (make-instance (quote voice) :tree (quote (2 (((4 4) (1 (1 (1 -2 1 1)) 1 1)) ((4 4) (1 (1 (1 2 1 1)) -1 1))))) :chords (load-obj-list-from-save (quote ((let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (400)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (200)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord)))) :tempo (quote ((1/4 60) nil)) :legato 100 :ties (quote (nil nil nil nil nil nil nil nil nil nil nil nil)))))) (load-port-info newobj (quote (((0) ((0) nil (0) (0)) (0) (0)) ((0) ((0) (0) (0) (0)) nil (0))))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-tonalite newobj nil) newobj))))) (om-make-point 97 474) (om-make-point 638 195) (if (find-class (quote poly) nil) (let ((newobj (make-instance (quote poly) :voices (list (let ((newobj (when (find-class (quote voice) nil) (make-instance (quote voice) :tree (quote (43/8 (((3 4) (3)) ((4 4) (2.0 2)) ((3 8) (3)) ((2 8) (2)) ((3 4) ((1 (1.0 1)) 2.0)) ((2 8) (2)) ((4 4) (1.0 (1 (1.0 1)) 2.0)) ((4 4) (2.0 (1 (1.0 1)) 1.0))))) :chords (load-obj-list-from-save (quote ((let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (2970)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1980)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1485)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (990)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (990)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord)))) :tempo (quote ((1/4 60) nil)) :legato 99 :ties (quote (nil nil nil nil nil nil nil nil)))))) (load-port-info newobj (quote (((0)) ((0) (0)) ((0)) ((0)) (((0) (0)) (0)) ((0)) ((0) ((0) (0)) (0)) ((0) ((0) (0)) (0))))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote voice) nil) (make-instance (quote voice) :tree (quote (43/8 (((3 4) ((1 (3 1)) 1 (1 (2.0 1 1)))) ((4 4) ((1 (1.0 1)) 1.0 2)) ((3 8) (3)) ((2 8) (1.0 (1 (1 1)))) ((3 4) ((1 (1.0 1)) 2.0)) ((2 8) (2)) ((4 4) ((1 (2.0 1 1)) (1 (2.0 1 1)) 1.0 (1 (1.0 1 2)))) ((4 4) ((1 (1.0 1 2)) (1 (1.0 1 2)) (1 (1.0 1 -2)) -1))))) :chords (load-obj-list-from-save (quote ((let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (742)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (990)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1980)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1485)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (990)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (2))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) thechord)))) :tempo (quote ((1/4 60) nil)) :legato 99 :ties (quote (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)))))) (load-port-info newobj (quote ((((0) (0)) (0) ((0) (0) (0))) (((0) (0)) (0) (0)) ((0)) ((0) ((0) (0))) (((0) (0)) (0)) ((0)) (((0) (0) (0)) ((0) (0) (0)) (0) ((0) (0) (0))) (((0) (0) (0)) ((0) (0) (0)) ((0) (0) nil) nil)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote voice) nil) (make-instance (quote voice) :tree (quote (43/8 (((3 4) ((1 (1 1 1 1)) (1 (1 1 1)) (1 (1 1 1 1)))) ((4 4) ((1 (1.0 1)) (1 (1 1)) (1 (1 1)) (1 (1.0 3)))) ((3 8) ((1 (2 1)) (1 (2.0 1)) (1 (2.0 1)))) ((2 8) ((1 (1.0 2)) (1 (1 1)))) ((3 4) ((1 (1 1 2)) (1 (1 1)) (1 (2 1 1)))) ((2 8) (1.0 (1 (1 1)))) ((4 4) ((1 (1.0 1 1 1)) (1 (1.0 1 1 1)) (1 (1 1 1 1)) (1 (1 1 2)))) ((4 4) ((1 (1.0 1 2)) (1 (1.0 1 2)) (1 (1.0 -3)) -1))))) :chords (load-obj-list-from-save (quote ((let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (330)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (330)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (330)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (742)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (330)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (165)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (165)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (165)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (330)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (248)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (495)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (3))))) (load-port-info thechord (quote (0))) thechord)))) :tempo (quote ((1/4 60) nil)) :legato 99 :ties (quote (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)))))) (load-port-info newobj (quote ((((0) (0) (0) (0)) ((0) (0) (0)) ((0) (0) (0) (0))) (((0) (0)) ((0) (0)) ((0) (0)) ((0) (0))) (((0) (0)) ((0) (0)) ((0) (0))) (((0) (0)) ((0) (0))) (((0) (0) (0)) ((0) (0)) ((0) (0) (0))) ((0) ((0) (0))) (((0) (0) (0) (0)) ((0) (0) (0) (0)) ((0) (0) (0) (0)) ((0) (0) (0))) (((0) (0) (0)) ((0) (0) (0)) ((0) nil) nil)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-tonalite newobj nil) newobj)) :from-file t))) (load-port-info newobj (quote ((((0)) ((0) (0)) ((0)) ((0)) (((0) (0)) (0)) ((0)) ((0) ((0) (0)) (0)) ((0) ((0) (0)) (0))) ((((0) (0)) (0) ((0) (0) (0))) (((0) (0)) (0) (0)) ((0)) ((0) ((0) (0))) (((0) (0)) (0)) ((0)) (((0) (0) (0)) ((0) (0) (0)) (0) ((0) (0) (0))) (((0) (0) (0)) ((0) (0) (0)) ((0) (0) nil) nil)) ((((0) (0) (0) (0)) ((0) (0) (0)) ((0) (0) (0) (0))) (((0) (0)) ((0) (0)) ((0) (0)) ((0) (0))) (((0) (0)) ((0) (0)) ((0) (0))) (((0) (0)) ((0) (0))) (((0) (0) (0)) ((0) (0)) ((0) (0) (0))) ((0) ((0) (0))) (((0) (0) (0) (0)) ((0) (0) (0) (0)) ((0) (0) (0) (0)) ((0) (0) (0))) (((0) (0) (0)) ((0) (0) (0)) ((0) nil) nil))))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-tonalite newobj nil) newobj)) nil nil (pairlis (quote (scale microplay obj-mode palette-mode approx fontsize staff cmnpref deltapict outport inport zoom notechancolor? grillestep mode winsize winpos show-stems)) (list nil nil 0 0 2 24 (list (quote g) (quote g) (quote g)) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1 1 1))) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) 0 0 1 nil 1000 0 18350450 2621450 (quote t))) t nil nil nil) (om-load-boxcall (quote genfun) "R-HIERARCHY11" (quote rc::r-hierarchy) (quote ((om-load-inputfun (quote input-funbox) "layernr" "LAYERHIGH" 1) (om-load-inputfun (quote input-funbox) "layernr" "LAYERLOW" 2))) (om-make-point 295 65) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list121" (quote list) (quote nil) (om-make-point 117 98) (om-make-point 136 35) (list 5/4 5/4 5/4 5/4 5/4 5/4 5/4) "(5/4 5/4 5/4 5/4$5/4 5/4 5/4)" nil) (om-load-boxcall (quote genfun) "PRESET-LAYER" (quote rc::preset-layer) (quote ((om-load-inputfun (quote input-funbox) "measurelayer" "RHYTHMSEQ" (list 1/4 1/4 1/4 1/4 1/4 1/4 1/4 1/4)))) (om-make-point 145 144) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list12" (quote list) (quote nil) (om-make-point 216 142) (om-make-point 88 33) (list (list 1) (list 3/8) (list 3/16) (list 1/16)) "((4/4)(3/8)$(3/16)(1/16))" nil) (om-load-boxcall (quote bastype) "list2" (quote list) (quote nil) (om-make-point 274 182) (om-make-point 90 55) (list (list 1/16) (list 1/8) (list 3/16) (list 1/20) (list 5/24) (list 1/12)) "((1/16)(1/8) (3/16)(1/20) (5/24)(1/12))" nil) (om-load-boxcall (quote genfun) "VOICE-DOMAIN1" (quote rc::voice-domain) (quote ((om-load-inputfun (quote input-funbox) "timesigns" "TIMESIGN-LIST" nil) (om-load-inputfun (quote input-funbox) "layer1" "RHYTHMCELL-LIST1" nil) (om-load-inputfun (quote input-funbox) "layer2" "RHYTHMCELL-LIST2" nil) (om-load-inputfun (quote input-funbox) "layer3" "RHYTHMCELL-LIST3" nil))) (om-make-point 151 260) nil nil nil nil 1) (om-load-boxcall (quote genfun) "DECODE-ENGINE1" (quote rc::decode-engine) (quote ((om-load-inputfun (quote input-funbox) "from engine" "SOL" nil) (om-load-inputfun (quote input-funbox) "bpm" "TEMPO" 60) (om-load-inputfunmenu1 (quote input-funmenu) "format" "OUTPUT" (quote rc::voice) (list (list "poly-list" (quote (quote rc::poly))) (list "voice-list" (quote (quote rc::voice))) (list "simple" (quote (quote rc::simple))))))) (om-make-point 327 399) nil nil nil nil 1) (om-load-boxcall (quote genfun) "R-BEAT-SUBDIV1" (quote rc::r-beat-subdiv) (quote ((om-load-inputfun (quote input-funbox) "rhythmlayer" "RHYTHM-LAYER-NR" 3) (om-load-inputfun (quote input-funbox) "beatvalue" "BEATVALUE1" 4) (om-load-inputfun (quote input-funbox) "subdiv-list" "SUBDIV1" (list 1 2 3 4 5)) (om-load-inputfun (quote input-funbox) "beatvalue" "BEATVALUE2" 8) (om-load-inputfun (quote input-funbox) "subdiv-list" "SUBDIV2" (list 1 2 3)))) (om-make-point 410 13) nil nil nil nil 1) (om-load-boxcall (quote genfun) "R-HIERARCHY1" (quote rc::r-hierarchy) (quote ((om-load-inputfun (quote input-funbox) "layernr" "LAYERHIGH" 2) (om-load-inputfun (quote input-funbox) "layernr" "LAYERLOW" 3))) (om-make-point 354 38) nil nil nil nil 1) (om-load-boxcall (quote genfun) "R-EQLENGTH2" (quote rc::r-eqlength) (quote ((om-load-inputfun (quote input-funbox) "layernr" "LAYER1" 0) (om-load-inputfun (quote input-funbox) "layernr" "LAYER2" 3))) (om-make-point 485 32) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "APPEND1" (quote append) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 375 143) (om-make-point 178 37) nil nil nil 1) (om-load-boxcall (quote genfun) "RULES->PMC1" (quote rc::rules->pmc) (quote ((om-load-inputfun (quote input-funbox) "rules" "VOICE0" nil))) (om-make-point 413 217) nil nil nil nil 1) (om-load-boxcall (quote genfun) "DOMAINS->PMC1" (quote rc::domains->pmc) (quote ((om-load-inputfun (quote input-funbox) "number of variables" "N-VAR" 80) (om-load-inputfun (quote input-funbox) "voice-domain" "VOICE0" nil))) (om-make-point 116 323) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 568 67) nil nil nil nil 1) (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "2ndNotEq" (quote ((om-load-boxcomment "comment" (om-make-point 542 91) (quote "This rule check if the variable belongs to layer 2 or not. If not, it always gives true as an output (i.e. it will not affect other layers than number 2). If it does belong to layer 2, it checks if the element is identical to the one in layer 2 immediately before it. If it is identical, the output is false, otherwise true.$$The rule will not allow repetitions of the same element in layer 2.") "" (om-make-point 214 407) nil (om-make-color 0 0 0) (om-make-font "Geneva" 10 :family "Geneva" :style (quote (:plain)) :mode (quote nil))) (om-load-boxcomment "comment11" (om-make-point 207 314) (quote "A user defined rule always has 2 inputs. They are normally not accessed directly, but are used by the tools in the \"user rule tools\" menu to give the user access to different things. A basic example is the box \"get-this-cell\":$$Get-this-cell only has 1 input, and it should be connected to the second input to the patch. It outputs the variable (i.e. the element from the domain) that is beeing checked at the moment. $$Get-last-cell has 2 inputs. They should be connected to the 2 inputs to the patch. It outputs the variable in the same layer as the one beeing checked at the moment, immediately before the one beeing checked. The engine has thus already accepted this variable as true according to all rules (but might now reconsider that decision...).$$Get-layer-number outputs the layer number for the variable beeing checked.") "" (om-make-point 526 32) nil (om-make-color 0 0 0) (om-make-font "Helvetica" 10 :family "Helvetica" :style (quote (:plain)) :mode (quote nil))) (om-load-boxcomment "comment1" (om-make-point 191 43) (quote "<-- The second input gives the variable beeing checked for the moment (as an object).") "" (om-make-point 309 59) nil (om-make-color 0 0 0) (om-make-font "Helvetica" 10 :family "Helvetica" :style (quote (:plain)) :mode (quote nil))) (om-load-boxcomment "comment" (om-make-point 214 71) (quote "<-- The first input gives the index  number for the variable the search engine is checking for the moment. This is used internally to keep track on where the engine is in the search.") "" (om-make-point 44 60) nil (om-make-color 0 0 0) (om-make-font "Helvetica" 10 :family "Helvetica" :style (quote (:plain)) :mode (quote nil))) (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 170 383) (om-make-point 18 28) (quote t) "t" nil) (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "if" "TEST" nil) (om-load-inputfun (quote input-funbox) "then" "ACTION" nil) (om-load-inputfun (quote input-funbox) "else" "ELSE" nil))) (om-make-point 124 410) (om-make-point 67 53) nil nil nil 1) (om-load-boxcall (quote bastype) "number" (quote number) (quote nil) (om-make-point 459 234) (om-make-point 20 28) 2 "2" nil) (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "SELF" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM" 0))) (om-make-point 423 264) (om-make-point 35 35) nil nil nil 1) (om-load-boxcall (quote genfun) "TEST-NOT-EQUAL" (quote rc::test-not-equal) (quote ((om-load-inputfun (quote input-funbox) "event" "EV1" nil) (om-load-inputfun (quote input-funbox) "event" "EV2" nil))) (om-make-point 116 298) nil nil nil nil 1) (om-load-boxcall (quote genfun) "GET-LAYERNUMBER" (quote rc::get-layernumber) (quote ((om-load-inputfun (quote input-funbox) "search-var" "X" nil))) (om-make-point 389 183) nil nil nil nil 1) (om-load-boxcall (quote genfun) "GET-LAST-CELL" (quote rc::get-last-cell) (quote ((om-load-inputfun (quote input-funbox) "index" "INDEXX" nil) (om-load-inputfun (quote input-funbox) "search-var" "X" nil))) (om-make-point 24 183) nil nil nil nil 1) (om-load-boxcall (quote genfun) "GET-THIS-CELL" (quote rc::get-this-cell) (quote ((om-load-inputfun (quote input-funbox) "search-var" "X" nil))) (om-make-point 205 183) nil nil nil nil 1) (om-load-boxin "input1" 1 (om-make-point 267 42) "no documentation" nil nil nil) (om-load-boxin "input" 0 (om-make-point 5 45) "no documentation" nil nil nil) (om-load-boxout "output" 0 (om-make-point 136 486) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (quote ((7 0 5 0 nil 0) (8 0 5 1 nil 0) (4 0 5 2 nil 0) (9 0 7 0 nil 0) (6 0 7 1 nil 0) (10 0 8 0 nil 0) (11 0 8 1 nil 0) (12 0 9 0 nil 0) (13 0 10 0 nil 0) (12 0 10 1 nil 0) (12 0 11 0 nil 0) (5 0 14 0 nil 0))) 6.04 nil) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil))) (om-make-point 559 1) nil nil "l" "2ndNotEq"))) (quote ((27 0 0 0 nil 0) (29 0 9 0 nil 0) (28 0 9 1 nil 0) (8 0 9 6 nil 0) (11 0 10 0 nil 0) (12 0 11 0 nil 0) (7 0 12 0 nil 0) (6 0 12 1 nil 0) (5 0 12 2 nil 0) (2 0 13 0 nil 0) (4 0 13 1 nil 0) (3 0 13 2 nil 0) (1 0 13 3 nil 0) (23 0 16 1 nil 0) (18 0 19 0 nil 0) (15 0 22 0 nil 0) (19 0 22 1 nil 0) (20 0 22 2 nil 0) (21 0 22 3 nil 0) (9 0 23 0 nil 0) (17 0 27 0 nil 0) (25 0 27 1 nil 0) (24 0 27 2 nil 0) (26 0 27 3 nil 0) (30 0 27 4 nil 0) (14 0 27 5 nil 0) (13 0 27 6 nil 0) (27 0 28 0 nil 0) (22 0 29 1 nil 0) (31 0 30 0 nil 0))) nil 6.04))
